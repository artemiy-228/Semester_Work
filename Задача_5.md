## Condition

```
Напишите функцию для симметричного (in-order) обхода бинарного дерева, заданного следующей структурой:
struct node { int value; node *left, *right; };
К каждому значению, хранящемуся в дереве, функция применяет функцию, указанную в качестве аргумента:
void inorder(node *n, void (*f)(int));
```

### Implementation

```
//Пример обхода
void inorder(Node *n, void (*f)(int)) {
    if (n == nullptr) {
        return;
    }
    inorder(n->left, f);
    f(n->value);
    inorder(n->right, f);
}
// Указатель на эту функцию мы передаем. нужна что бы проверить правильность обхода
void printNode(int value){
    cout << value << "-> ";
}

//Рекурсивная функция удаления узлов(что бы не было утечек)
void clear(Node *n) {
    if (n == nullptr) {
        return;
    }
    clear(n->left);
    clear(n->right);
    delete n;
}
```

### Testing

```
int main() {
    Node *tree = new Node(0, 
                          new Node(1, 
                                   new Node(3), 
                                   new Node(4)), 
                          new Node(2, 
                                   new Node(5), 
                                   new Node(6)));
    inorder(tree, printNode);
    clear(tree);
}
```

### Outputs
```
Input: 
        0
       / \
     1     2
    / \   / \
    3  4  5 6

Output: 
3-> 1-> 4-> 0-> 5-> 2-> 6->

Expected output:
3-> 1-> 4-> 0-> 5-> 2-> 6->

```